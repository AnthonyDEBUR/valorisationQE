# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand # nolint: line_length_linter.

#' f_cartographie_concentrations
#' 
#' Génère une carte des concentrations en polluants
#'
#' Cette fonction permet de représenter spatialement les concentrations en 
#' polluants mesurées lors d'une campagne de prélèvements, en utilisant une 
#' carte de fond et des données géolocalisées. Les concentrations sont classées 
#' selon des seuils définis et affichées avec une légende personnalisée.
#'
#' @param fond_carte Objet `ggplot` représentant la carte de fond, par exemple 
#' généré avec la fonction f_fond_de_carte 
#' @param shp_staq Objet sf contenant les points de suivis à afficher. Seuls les
#' points dont le code SANDRE est présent dans data_carte seront affichés.
#' @param data_carte Data frame contenant les données de prélèvement, incluant 
#' les colonnes de date de prélèvement, de code SANDRE des stations et la 
#' colonne de valeurs à cartographier.
#' @param col_stations Nom de la colonne contenant les codes sandre des stations 
#' de mesure à afficher (par défaut `"CdStationMesureEauxSurface"`). Si ce nom
#' de colonne est différent pour shp_staq et data_carte alors col_station 
#' est un vecteur dont la première valeur est le nom de la colonne de shp_staq 
#' et la deuxième celle de data_carte
#' @param col_valeurs Nom de la colonne contenant les valeurs de concentration à
#' utiliser (par défaut `"Somme"`).
#' @param titre Titre principal de la carte (par défaut `"Bilan des concentrations en pesticides"`).
#' @param sous_titre Sous-titre de la carte.
#' @param breaks Vecteur numérique définissant les seuils de classes de 
#' concentration (par défaut `c(0, 0.5, 2, Inf)`).
#' @param values Vecteur de couleurs correspondant aux classes de concentration 
#' (par défaut `c("cyan", "yellow", "red", "black")`).
#' @param pts_size Taille des points représentant les stations (par défaut `6`).
#' @param text_size Taille du texte des étiquettes (par défaut `5`).
#' @param unite Unité des concentrations affichée dans la légende et les 
#' étiquettes (par défaut `"µg/L"`).
#' @param nom_legende Titre de la légende des couleurs (par 
#' défaut `"Concentrations"`).
#' @param nb_decimal_text Nombre de décimales à afficher dans les étiquettes 
#' (par défaut `1`).
#' @param label.size taille de l'étiquette (défaut = 0.25). Voir geom_text_repel
#' du package ggrepel 
#' (par défaut `1`).
#' @param box.padding Marge autour de l'étiquette (par défaut 0.35) Voir 
#' geom_text_repel du package ggrepel 
#' @param point.padding Marge autour de l'étiquette (par défaut 0.3) Voir 
#' geom_text_repel du package ggrepel
#' @param segment.color Couleur du segment liant les points à leurs étiquettes. 
#' grey50 par défaut. Voir geom_text_repel du package ggrepel 
#' @param min.segment.length Longueur mini entre un point et son étiquette 
#' (par défaut 0) Voir geom_text_repel du package ggrepel 
#' 
#' 
#' @return Un objet `ggplot` représentant la carte des concentrations avec 
#' légende, points colorés selon les classes, et étiquettes.
#'
#' @import ggplot2
#' @import sf
#' @import dplyr
#' @import ggrepel
#'
#' @export
#' @examples
#'
#' library(sf)
#' library(dplyr)
#'
#' # Coordonnées approximatives des centres des communes
#' coords <- data.frame(
#'   code = c("A", "B", "C"),
#'   commune = c("Châteaugiron", "Janzé", "Thourie"),
#'   lon = c(-1.499, -1.498, -1.4833),
#'   lat = c(48.052, 47.960, 47.8550)
#' )
#'
#' # Création de l'objet sf
#' points_sf <- st_as_sf(coords, coords = c("lon", "lat"), crs = 4326)
#'
#'
#' # bassin versant
#'    triangle_sf <- sf::st_sf(
#'         geometry = sf::st_sfc(
#'           sf::st_polygon(list(rbind(
#'             c(-1.6794, 48.1147),  # Rennes
#'             c(-1.2100, 48.1230),  # Vitré
#'             c(-1.5025, 47.6833),  # Derval
#'             c(-1.6794, 48.1147)   # Retour à Rennes
#'           )))
#'         ),
#'         crs = 4326
#'       )
#'
#' fond_carte<-f_fond_de_carte(triangle_sf, zoom=10)
#'
#' # Création du data.frame
#' df_valeurs <- data.frame(
#'   code = c("A", "B", "C"),
#'   valeur = c(0.23, 0.71, 3.52)
#' )
#'
#' f_cartographie_concentrations(fond_carte,
#'                               shp_staq=points_sf,
#'                               data_carte=df_valeurs,
#'                               col_stations="code",
#'                               col_valeurs="valeur",
#'                               titre="Bilan des concentrations en pesticides",
#'                               sous_titre="Date de la campagne",
#'                               breaks=c(0, 0.5, 2, Inf),
#'                               values = c("cyan", "yellow", "red", "black"),
#'                               pts_size=6,
#'                               text_size=5,
#'                               unite="µg/L",
#'                               nom_legende="Concentrations",
#'                               nb_decimal_text=1)
#'
f_cartographie_concentrations <-function(fond_carte,
                                         shp_staq,
                         data_carte,
                         col_stations="CdStationMesureEauxSurface",
                         col_valeurs="Somme",
                         titre="Bilan des concentrations en pesticides",
                         sous_titre="Date de la campagne",
                         breaks=c(0, 0.5, 2, Inf),
                         values = c("cyan", "yellow", "red", "black"),
                         pts_size=6,
                         text_size=5,
                         unite="µg/L",
                         nom_legende="Concentrations",
                         nb_decimal_text=1,
                         label.size=0.25,
                         box.padding = 0.35,
                     point.padding = 0.3,
                     segment.color = "grey50",
                     min.segment.length = 0
){

# Vérification des types d'objets
if (!inherits(fond_carte, "gg")) {
  stop("Erreur : 'fond_carte' doit être un objet ggplot, par exemple généré avec la fonction f_fond_de_carte.")
}

if (!inherits(shp_staq, "sf")) {
  stop("Erreur : 'shp_staq' doit être un objet sf contenant les points de suivi.")
}

if (!is.data.frame(data_carte)) {
  stop("Erreur : 'data_carte' doit être un data.frame contenant les données de prélèvement.")
}

# Vérification des noms de colonnes

if (!is.character(col_stations) || !(length(col_stations) %in% c(1, 2))) {
  stop("Erreur : 'col_stations' doit être une chaîne ou un vecteur de deux chaînes : nom de la colonne dans 'shp_staq' et dans 'data_carte'.")
}

if (length(col_stations) == 1) {
  col_stations_shp <- col_stations
  col_stations_data <- col_stations
} else {
  col_stations_shp <- col_stations[1]
  col_stations_data <- col_stations[2]
}

if (!col_stations_data %in% colnames(data_carte)) {
  stop(paste0("Erreur : La colonne '", col_stations_data, "' est absente de 'data_carte'."))
}

if (!col_stations_shp %in% colnames(shp_staq)) {
  stop(paste0("Erreur : La colonne '", col_stations_shp, "' est absente de 'shp_staq'."))
}

if (!col_valeurs %in% colnames(data_carte)) {
  stop(paste0("Erreur : La colonne '", col_valeurs, "' est absente de 'data_carte'."))
}

# Vérification de la cohérence entre breaks et values
if (length(breaks) != length(values)) {
  stop(paste0("Erreur : Le vecteur 'values' doit contenir ", length(breaks) - 1, " couleurs, correspondant aux ", length(breaks) - 1, " classes définies par 'breaks'."))
}
  
  if (!is.numeric(breaks)) {
  stop("'breaks' doit être un vecteur numérique.")
}
if (!is.character(values)) {
  stop("'values' doit être un vecteur de chaînes de caractères représentant des couleurs.")
}


# Vérification des tailles
if (!is.numeric(pts_size) || pts_size <= 0) {
  stop("Erreur : 'pts_size' doit être un nombre numérique strictement positif.")
}

if (!is.numeric(text_size) || text_size <= 0) {
  stop("Erreur : 'text_size' doit être un nombre numérique strictement positif.")
}

if (!is.numeric(nb_decimal_text) || nb_decimal_text < 0) {
  stop("Erreur : 'nb_decimal_text' doit être un entier positif ou nul.")
}

  if (!is.numeric(label.size) || label.size < 0) {
  stop("'label.size' doit être un nombre positif.")
}
if (!is.numeric(box.padding) || box.padding < 0) {
  stop("'box.padding' doit être un nombre positif.")
}
if (!is.numeric(point.padding) || point.padding < 0) {
  stop("'point.padding' doit être un nombre positif.")
}
if (!is.numeric(min.segment.length) || min.segment.length < 0) {
  stop("'min.segment.length' doit être un nombre positif ou nul.")
}

  if (!is.character(segment.color) || length(segment.color) != 1) {
  stop("'segment.color' doit être une chaîne de caractères représentant une couleur.")
}

  
  
   shp_staq$CdStationMesureEauxSurface<-shp_staq[[col_stations_shp]]
  data_carte$CdStationMesureEauxSurface<-data_carte[[col_stations_data]]
  data_carte$Somme<-data_carte[[col_valeurs]]

  data_carte<-right_join(shp_staq, data_carte, by=c("CdStationMesureEauxSurface"))
  # on définit les classes de concentration.
  # data_carte$classe_somme_pesticides<-cut(data_carte$Somme, breaks = breaks)

  data_carte_legend<-data_carte%>%st_drop_geometry()
  data_carte_legend$X<-st_coordinates(data_carte)[,"X"]
  data_carte_legend$Y<-st_coordinates(data_carte)[,"Y"]

  # Créer les étiquettes
  labels <- paste0(breaks[-length(breaks)], "-", breaks[-1], unite)
  labels[length(labels)] <- paste0(">", breaks[length(breaks) - 1], unite)

  # Créer les niveaux de facteur correspondants
  data_carte$classe_somme_pesticides <- cut(data_carte$Somme, breaks = breaks, include.lowest = TRUE)
  labels <- paste0(breaks[-length(breaks)], "-", breaks[-1], unite)
  labels[length(labels)] <- paste0(">", breaks[length(breaks) - 1], unite)
  levels(data_carte$classe_somme_pesticides) <- labels
 
  data_carte_legend$label <- paste0(
    data_carte_legend$CdStationMesureEauxSurface,
    "\n",
    round(data_carte_legend$Somme, nb_decimal_text),
    " ",
    unite
  )
  
  

  g<-fond_carte +
    geom_sf(data = data_carte,
            inherit.aes=FALSE,
            aes(color=classe_somme_pesticides),
            size=pts_size
    ) +
    scale_color_manual(values = values,
                       labels = labels,
                       drop=FALSE)+
    geom_sf(data = data_carte,
            inherit.aes=FALSE,
            color="black",
            fill=NA,
            stroke=0.5,
            shape=21,
            size=pts_size
    ) +
        geom_label_repel(data = data_carte_legend,
                     aes(x = X, y = Y, label = label),
                     size = text_size,
                     inherit.aes = FALSE,
                     label.size = label.size,
                     box.padding = box.padding,
                     point.padding = point.padding,
                     segment.color = segment.color,
                     min.segment.length = min.segment.length)+
      ggtitle(label=titre,
            subtitle = sous_titre) +
    labs(x = "", y = "", color = nom_legende) +
    theme_minimal() +
    theme(axis.text = element_blank(), # masque les valeurs des axes
          axis.ticks = element_blank(), # masque les ticks
          axis.title = element_blank()) # masque les titres des axes

  return(g)}

