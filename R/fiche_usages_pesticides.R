# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand # nolint: line_length_linter.

#' fiche_usages_pesticides
#' Génère un tableau graphique des usages autorisés ou interdits des pesticides par culture
#'
#' Cette fonction permet de visualiser, sous forme de tableau coloré, les usages des substances actives
#' (pesticides) selon leur statut réglementaire : autorisé, interdit ou jamais autorisé, pour différentes cultures.
#' Les couleurs indiquent :
#' - **vert** : la substance est actuellement autorisée sur la culture
#' - **rouge** : la substance a été retirée de l'autorisation
#' - **blanc** : la substance n'a jamais été autorisée sur la culture
#'
#' @param liste_cd_sandre Character vector. Liste des codes SANDRE des masses d'eau pour lesquelles on souhaite afficher les usages.
#' @param liste_pesticides Data frame. Issu de la fonction `importe_ref_pestibase`, contenant au minimum les colonnes :
#' - `SA_CodeSANDRE` : code SANDRE de la masse d'eau
#' - `name_fr` : nom de la substance active
#' - `function_finale` : fonction associée à la substance
#' - `has_authorized_oepp_culture` : texte décrivant les cultures pour lesquelles la substance est autorisée
#' - `has_removed_authorized_oepp_culture` : texte décrivant les cultures pour lesquelles l'autorisation a été retirée
#'
#' @return Un objet graphique de type `grob` représentant un tableau coloré des usages par culture.
#' Ce tableau peut être affiché avec `grid::grid.draw()`.
#'
#' @export
#' @examples
#' ref_pestibase <- importe_ref_pestibase()
#'
#' fiche_usages_pesticides(liste_cd_sandre=c("2009", "1221", "1882", "5817"),
#'                                         liste_pesticides=ref_pestibase$liste_pesticides)
#'
#'
fiche_usages_pesticides <- function(liste_cd_sandre, 
                                    liste_pesticides) {

  
    # Fonction logique oui/non
est_autorise_sur_culture <- function(aut, interd, motif) {
  aut <- ifelse(is.na(aut), "", aut)
  interd <- ifelse(is.na(interd), "", interd)
  
  aut_detect <- stringr::str_detect(aut, motif)
  interd_detect <- stringr::str_detect(interd, motif)
  
  dplyr::case_when(
    aut_detect ~ "oui",
    interd_detect ~ "non",
    TRUE ~ NA_character_
  )
}

  # 
  liste_pesticides_a_traiter <- liste_pesticides %>%
    dplyr::mutate(SA_CodeSANDRE = factor(SA_CodeSANDRE, levels = liste_cd_sandre)) %>%
    dplyr::arrange(SA_CodeSANDRE) %>%
    dplyr::mutate(
      Fonction = liste_pesticides$function_finale,
      `Céréales à paille` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Avoine|Blé|Orge|Riz|Sarrasin|Seigle|Céréales"),
      `Maïs` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Maïs"),
      `Oléagineux` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Arachide|Chanvre|Crucifères|Soja|Tournesol"),
      `Prairies` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Prairie"),
      `Fourrages` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Fourragères|Prairies"),
      `Pomme de terre` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Pomme de terre"),
      `Betterave` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Betterave"),
      `Légumes` = est_autorise_sur_culture(has_authorized_oepp_culture, has_removed_authorized_oepp_culture, "Artichaut|Asperge|Carotte|Céleri|Chicorée|Choux|Cresson|Cucurbitacées|Epinard|Haricot|Laitue|Navet|Oignon|Poireau|Pois|Poivron|Salsifis|Tomate|Aubergine|Légumes")
    )%>%subset(SA_CodeSANDRE%in%liste_cd_sandre)
  
  # on s'assure que toutes les colonnes de fonction sont de type character et non logical (cas où aucun usage n'est renseigné dans le tableau)
  convertir_logical_en_character <- function(df) {
    df[sapply(df, is.logical)] <- lapply(df[sapply(df, is.logical)], as.character)
    return(df)
  }
  
  liste_pesticides_a_traiter <- convertir_logical_en_character(liste_pesticides_a_traiter)
  
  # Sélection et ordre des colonnes
  tableau_final <- liste_pesticides_a_traiter %>%
    dplyr::select(name_fr, Fonction,
                  `Céréales à paille`, `Maïs`, `Oléagineux`, `Prairies`,
                  `Fourrages`, `Pomme de terre`, `Betterave`, `Légumes`) %>%
    dplyr::rename(Substance = name_fr) %>%
    dplyr::distinct()%>%
    dplyr::mutate(dplyr::across(everything(), as.character)) %>%
    dplyr::mutate(dplyr::across(everything(), ~tidyr::replace_na(.x, "")))
  

  # Création du tableau graphique avec couleurs conditionnelles
  
  tableau_grob <- gridExtra::tableGrob(tableau_final, 
                                       rows = NULL, 
                                       theme = gridExtra::ttheme_default(
    core = list(fg_params = list(cex = 0.8)),
    colhead = list(fg_params = list(cex = 0.8, rot = 45))
  ))
  
  
  # Extraire les données à colorer (colonnes 3 à n)
valeurs <- tableau_final[, 3:ncol(tableau_final)]

# Créer une matrice de couleurs
couleurs <- apply(valeurs, c(1, 2), function(val) {
  if (is.na(val) || val == "") return("white")
  if (val == "oui") return("darkgreen")
  if (val == "non") return("red")
  return("white")
})
  

layout <- tableau_grob$layout

for (i in seq_len(nrow(couleurs))) {
  for (j in seq_len(ncol(couleurs))) {
    # Indices dans layout (décalage de +1 pour les lignes à cause des en-têtes)
    row_idx <- i + 1
    col_idx <- j + 2  # car Substance et Fonction sont les deux premières colonnes

    cell_bg <- which(layout$t == row_idx & layout$l == col_idx & grepl("core-bg", layout$name))
    if (length(cell_bg) == 1) {
      tableau_grob$grobs[[cell_bg]]$gp <- grid::gpar(fill = couleurs[i, j], col = NA)
    }
  }
}

  grid::grid.newpage()
tableau_grob<-grid::grid.draw(tableau_grob)
  
  return(tableau_grob)
}

